#!/usr/bin/env node

/**
 * Fix Strategies Module
 * Catalog of automated fixes for common installation and startup errors
 * Each strategy makes minimal, surgical changes
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

const FIX_STRATEGIES = {
  /**
   * Create minimal .env file with required variables or fix empty POSTGRES_URL
   */
  CREATE_ENV_FILE: {
    name: 'create_env_file',
    description: 'Create .env file from template with minimal required variables',
    applies: ['env_missing'],
    async execute({ projectRoot = process.cwd(), logger = console }) {
      const envPath = path.join(projectRoot, '.env');
      const envExamplePath = path.join(projectRoot, '.env.example');

      // Check if .env exists
      if (fs.existsSync(envPath)) {
        // Check if POSTGRES_URL is empty
        let envContent = fs.readFileSync(envPath, 'utf8');
        
        // Pattern to match POSTGRES_URL= (empty or just whitespace)
        if (/POSTGRES_URL\s*=\s*$/m.test(envContent)) {
          logger.log('‚ö†Ô∏è  Found empty POSTGRES_URL in .env, setting default value');
          
          // Replace empty POSTGRES_URL with default value
          envContent = envContent.replace(
            /POSTGRES_URL\s*=\s*$/m,
            'POSTGRES_URL=postgresql://postgres:password@localhost:5432/echotune_ai'
          );
          
          fs.writeFileSync(envPath, envContent);
          logger.log('‚úÖ Set POSTGRES_URL to default value');
          logger.log('üí° You can change this later to point to your actual database');
          return { success: true, message: 'Fixed empty POSTGRES_URL' };
        } else if (!/POSTGRES_URL/i.test(envContent)) {
          logger.log('‚ö†Ô∏è  POSTGRES_URL missing in .env, adding it');
          
          // Add POSTGRES_URL
          envContent = `POSTGRES_URL=postgresql://postgres:password@localhost:5432/echotune_ai\n${envContent}`;
          
          fs.writeFileSync(envPath, envContent);
          logger.log('‚úÖ Added POSTGRES_URL to .env');
          return { success: true, message: 'Added POSTGRES_URL' };
        }
        
        logger.log('‚úÖ .env file already exists with POSTGRES_URL set');
        return { success: true, message: '.env already exists' };
      }

      let envContent = '';

      // Try to copy from .env.example
      if (fs.existsSync(envExamplePath)) {
        envContent = fs.readFileSync(envExamplePath, 'utf8');
        logger.log('üìã Using .env.example as template');
        
        // Ensure POSTGRES_URL has a value
        if (/POSTGRES_URL\s*=\s*$/m.test(envContent)) {
          envContent = envContent.replace(
            /POSTGRES_URL\s*=\s*$/m,
            'POSTGRES_URL=postgresql://postgres:password@localhost:5432/echotune_ai'
          );
          logger.log('‚úÖ Set POSTGRES_URL to default value');
        }
      } else {
        // Create minimal .env
        envContent = `# EchoTune AI - Minimal Environment Configuration
# Generated by reliable-install-agent

# Database (Required for Prisma)
POSTGRES_URL=postgresql://postgres:password@localhost:5432/echotune_ai

# Disable optional features for initial setup
ENABLE_TRACING=false
ENABLE_AGENTOPS=false

# Server
NODE_ENV=development
PORT=3000

# Add Spotify credentials when ready
# SPOTIFY_CLIENT_ID=
# SPOTIFY_CLIENT_SECRET=
# SPOTIFY_REDIRECT_URI=http://localhost:3000/callback

# Add AI provider keys when ready
# GEMINI_API_KEY=
# OPENAI_API_KEY=
`;
        logger.log('üìã Creating minimal .env from scratch');
      }

      fs.writeFileSync(envPath, envContent);
      logger.log('‚úÖ Created .env file');
      return { success: true, message: 'Created .env file' };
    }
  },

  /**
   * Disable OpenTelemetry tracing if causing issues
   */
  DISABLE_TRACING: {
    name: 'disable_tracing',
    description: 'Disable OpenTelemetry tracing by setting ENABLE_TRACING=false',
    applies: ['opentelemetry'],
    async execute({ projectRoot = process.cwd(), logger = console }) {
      const envPath = path.join(projectRoot, '.env');

      if (!fs.existsSync(envPath)) {
        logger.log('‚ùå No .env file found, cannot disable tracing');
        return { success: false, message: 'No .env file' };
      }

      let envContent = fs.readFileSync(envPath, 'utf8');

      // Check if already disabled
      if (/ENABLE_TRACING\s*=\s*false/i.test(envContent)) {
        logger.log('‚úÖ ENABLE_TRACING already set to false');
        return { success: true, message: 'Already disabled' };
      }

      // Add or update ENABLE_TRACING
      if (/ENABLE_TRACING/i.test(envContent)) {
        envContent = envContent.replace(
          /ENABLE_TRACING\s*=\s*.*/i,
          'ENABLE_TRACING=false'
        );
        logger.log('‚úÖ Updated ENABLE_TRACING=false');
      } else {
        envContent = `ENABLE_TRACING=false\n${envContent}`;
        logger.log('‚úÖ Added ENABLE_TRACING=false');
      }

      fs.writeFileSync(envPath, envContent);
      return { success: true, message: 'Disabled tracing' };
    }
  },

  /**
   * Generate Prisma client
   */
  GENERATE_PRISMA: {
    name: 'generate_prisma',
    description: 'Generate Prisma client',
    applies: ['prisma_client'],
    async execute({ projectRoot = process.cwd(), logger = console }) {
      try {
        logger.log('üîß Generating Prisma client...');
        execSync('npm run db:generate', {
          cwd: projectRoot,
          stdio: 'inherit'
        });
        logger.log('‚úÖ Prisma client generated');
        return { success: true, message: 'Prisma client generated' };
      } catch (error) {
        logger.error('‚ùå Failed to generate Prisma client:', error.message);
        return { success: false, message: error.message };
      }
    }
  },

  /**
   * Initialize database schema
   */
  INIT_DATABASE: {
    name: 'init_database',
    description: 'Initialize database schema (db:push)',
    applies: ['prisma_migration', 'prisma_client'],
    async execute({ projectRoot = process.cwd(), logger = console }) {
      try {
        logger.log('üîß Initializing database schema...');
        execSync('npm run db:push', {
          cwd: projectRoot,
          stdio: 'inherit'
        });
        logger.log('‚úÖ Database schema initialized');
        return { success: true, message: 'Database initialized' };
      } catch (error) {
        logger.error('‚ùå Failed to initialize database:', error.message);
        return { success: false, message: error.message };
      }
    }
  },

  /**
   * Clean install dependencies
   */
  CLEAN_INSTALL: {
    name: 'clean_install',
    description: 'Remove node_modules and reinstall (npm ci)',
    applies: ['npm_install', 'module_not_found'],
    async execute({ projectRoot = process.cwd(), logger = console }) {
      try {
        logger.log('üßπ Cleaning node_modules...');
        const nodeModulesPath = path.join(projectRoot, 'node_modules');
        if (fs.existsSync(nodeModulesPath)) {
          fs.rmSync(nodeModulesPath, { recursive: true, force: true });
        }

        logger.log('üì¶ Running npm ci...');
        execSync('npm ci', {
          cwd: projectRoot,
          stdio: 'inherit'
        });
        logger.log('‚úÖ Clean install completed');
        return { success: true, message: 'Clean install successful' };
      } catch (error) {
        logger.error('‚ùå Clean install failed:', error.message);
        return { success: false, message: error.message };
      }
    }
  },

  /**
   * Kill process on port and retry
   */
  KILL_PORT: {
    name: 'kill_port',
    description: 'Kill process using the port',
    applies: ['port_in_use'],
    async execute({ port = 3000, logger = console }) {
      try {
        logger.log(`üîß Attempting to kill process on port ${port}...`);
        
        // Try lsof approach (Unix-like systems)
        try {
          execSync(`lsof -ti:${port} | xargs kill -9`, { stdio: 'pipe' });
          logger.log(`‚úÖ Killed process on port ${port}`);
          return { success: true, message: `Killed port ${port}` };
        } catch (lsofError) {
          // lsof might not be available or no process found
          logger.log(`‚ö†Ô∏è  No process found on port ${port} or lsof not available`);
          return { success: true, message: 'No process to kill' };
        }
      } catch (error) {
        logger.error(`‚ùå Failed to kill port ${port}:`, error.message);
        return { success: false, message: error.message };
      }
    }
  },

  /**
   * Update package.json to add missing scripts
   */
  ADD_MISSING_SCRIPTS: {
    name: 'add_missing_scripts',
    description: 'Add commonly needed scripts to package.json',
    applies: ['npm_install'],
    async execute({ projectRoot = process.cwd(), logger = console }) {
      const packageJsonPath = path.join(projectRoot, 'package.json');
      
      if (!fs.existsSync(packageJsonPath)) {
        logger.error('‚ùå No package.json found');
        return { success: false, message: 'No package.json' };
      }

      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
      
      // Check if essential scripts exist
      const essentialScripts = {
        'db:generate': 'node -r dotenv/config node_modules/.bin/prisma generate',
        'db:push': 'node -r dotenv/config node_modules/.bin/prisma db push',
        'db:init': 'npm run db:generate && npm run db:push'
      };

      let added = false;
      packageJson.scripts = packageJson.scripts || {};

      for (const [scriptName, scriptCmd] of Object.entries(essentialScripts)) {
        if (!packageJson.scripts[scriptName]) {
          packageJson.scripts[scriptName] = scriptCmd;
          logger.log(`‚úÖ Added script: ${scriptName}`);
          added = true;
        }
      }

      if (added) {
        fs.writeFileSync(
          packageJsonPath,
          JSON.stringify(packageJson, null, 2) + '\n'
        );
        logger.log('‚úÖ Updated package.json');
        return { success: true, message: 'Added missing scripts' };
      } else {
        logger.log('‚úÖ All essential scripts already exist');
        return { success: true, message: 'No changes needed' };
      }
    }
  }
};

/**
 * Get applicable fix strategies for an error category
 * @param {string} category - Error category
 * @returns {Array<Object>} Array of applicable fix strategies
 */
function getApplicableStrategies(category) {
  return Object.values(FIX_STRATEGIES).filter(strategy =>
    strategy.applies.includes(category)
  );
}

/**
 * Execute a fix strategy
 * @param {string} strategyName - Name of the strategy to execute
 * @param {Object} context - Execution context (projectRoot, logger, etc.)
 * @returns {Promise<Object>} Result of execution
 */
async function executeStrategy(strategyName, context = {}) {
  const strategy = Object.values(FIX_STRATEGIES).find(
    s => s.name === strategyName
  );

  if (!strategy) {
    throw new Error(`Unknown strategy: ${strategyName}`);
  }

  return await strategy.execute(context);
}

/**
 * Execute all applicable strategies for an error category
 * @param {string} category - Error category
 * @param {Object} context - Execution context
 * @returns {Promise<Array>} Array of results
 */
async function executeApplicableStrategies(category, context = {}) {
  const strategies = getApplicableStrategies(category);
  const results = [];

  for (const strategy of strategies) {
    const logger = context.logger || console;
    logger.log(`\nüîß Applying strategy: ${strategy.description}`);
    
    try {
      const result = await strategy.execute(context);
      results.push({
        strategy: strategy.name,
        ...result
      });

      // Stop if a strategy fails critically
      if (!result.success && strategy.applies.includes('critical')) {
        logger.error('‚ùå Critical strategy failed, stopping');
        break;
      }
    } catch (error) {
      logger.error(`‚ùå Strategy ${strategy.name} threw error:`, error.message);
      results.push({
        strategy: strategy.name,
        success: false,
        message: error.message
      });
    }
  }

  return results;
}

module.exports = {
  FIX_STRATEGIES,
  getApplicableStrategies,
  executeStrategy,
  executeApplicableStrategies
};

// CLI usage
if (require.main === module) {
  const args = process.argv.slice(2);

  if (args.length === 0) {
    console.log('Available fix strategies:');
    Object.values(FIX_STRATEGIES).forEach(strategy => {
      console.log(`  - ${strategy.name}: ${strategy.description}`);
      console.log(`    Applies to: ${strategy.applies.join(', ')}`);
    });
    process.exit(0);
  }

  const strategyName = args[0];
  const context = {
    projectRoot: process.cwd(),
    logger: console
  };

  executeStrategy(strategyName, context)
    .then(result => {
      console.log('\nResult:', result);
      process.exit(result.success ? 0 : 1);
    })
    .catch(error => {
      console.error('Error:', error.message);
      process.exit(1);
    });
}
